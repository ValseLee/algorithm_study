/*
    컴퓨터의 메모리는 메모리 셀의 연속.
    셀의 크기는 1byte, 각 셀은 고유한 16진수 주소가 있다.
    정수 타입 int 변수는 4byte를 예약하여 저장된다.
    각 주소는 & 기호로 접근할 수 있고 변수의 "첫번째" 주소를 가리킨다.

    이 주소를 담는 타입을 포인터 타입이라 한다.
    "변수의 타입에 무관하게" OS가 32bit 이면 4byte, 64bit면 8byte로 고정되어 있다.
    포인터 타입을 정의하려면 * 애스터릭 기호를 활용한다.
    포인터 타입의 크기는 고정되어있찌 않고 4, 8 byte의 크기를 갖는다.
    **즉, 1byte char 변수의 포인터는 1byte의 크기가 아니다.**

    포인터는 메모리의 동적 할당과 copy 없이 데이터를 함수의 매개변수로 전달할 수 있고,
    "Linked List"에서 활용된다.

    애스터릭 연산자는 이항 연산자로 사용할 땐 곱셈으로 활용할 수도 있고
    경우에 따라 "역참조"도 가능하다.

    배열의 이름을 포인터에 할당할 수 있는데, 이 경우 배열 크기 정보는 희석된다(decay).
    대신 배열의 0번째 요소의 주소가 포인터의 주소로 할당되는데 이를 통해 배열 이름을 배열 첫번째 주소로 활용이 가능해진다.
    인덱스 없이 총 범위를 함의하는 벡터 타입은 불가능.
    
    나중에 벡터와 배열을 정리해야할듯?
*/

#include<bits/stdc++.h>
using namespace std;

int main() {
    int i;
    cout << &i << "\n"; // 0x16f8b2f38 (변수 위치만 선언)
    i = 0;
    cout << &i << "\n"; // 0x16f8b2f38 (변수에 값까지 할당, 주소는 유지됨)

    string s = "valse";

    int *a = & i;
    string *b = &s;

    cout << a << '\n'; // 0x16f8b2f38
    cout << b << '\n'; // 0x16b1eef30 
    cout << *b << '\n'; // 0x16b1eef30에 접근하여 값을 꺼내옴 -> valse

    int c[3] = { 1,2,3 };
    int *d = &c[0]; // c 배열의 0번째 요소 주소를 전달.
    int *e = c; // c 배열 자체의 주소를 전달.

    cout << d << '\n'; // 0x16b36af38
    cout << e << '\n'; // 0x16b36af38 둘의 주소는 동일

    return 0;
}